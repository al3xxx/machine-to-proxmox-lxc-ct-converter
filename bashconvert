#!/usr/bin/env bash

# Will require jq for pvesh result parsing 
# Add check remote sql running, echo warning to 
# keep db files integrity
# Add ssh keys options
# Check if the pct, pvesh, jq  commands available
# on the host machine (Proxmox)

check_prereq() {
  for cmd in pvesh pct jq
  do
    if ! command -v $cmd &> /dev/null
    then
        echo "$cmd could not be found. This script must be run on the \
          Proxmox server"
        exit 1
    fi
  done
}

# Get next available vmid
getid() {
  #vmids=$(pvesh get /cluster/resources --type vm | jq -r '.[].vmid' | sort -n )
  #next_id=100
#
  #for id in $vmids
  #do
    #[[ "$next_id" -eq "$id" ]] && next_id=$((next_id + 1))
  #done
next_id="$(expr \
  $(
  pvesh get /cluster/resources --type vm --output-format json-pretty \
    | jq -r '.[].vmid' | sort -n | tail -1
    ) + 1
  )"
return $next_id
}


# Function to display script usage
usage()
{
  cat <<EOF
$1 -h|--help
 -c|--conf config file name (default /etc/${1}.conf)
 -n|--name [LXC container name]
 -t|--target [target machine SSH URI]
 -P|--port [target SSH port]
 -i|--id [Proxmox container ID]
 -r|--root [rootfs size in GB]
 -a|--ip [target container IP]
 -b|--bridge [bridge interface]
 -g|--gw [gateway IP]
 -m|--ram [memory in MB]
 -d|--data [target Proxmox storage pool]
 -p|--pass [root password for container (min. 5 chars)]
EOF
    return 0
}
# pct create command line syntax
# pct create <vmid> <ostemplate> [OPTIONS]
# --arch <amd64 | arm64 | armhf | i386 | riscv32 | riscv64> (default =
#        amd64)  - irrelevant, always assume amd64
# --cores <integer> - number of CPU cores, we set default 2 in config
# --cpulimit <number> (0 - 8192) (default = 0) - won't use for now
# --force <boolean>
#            Allow to overwrite existing container. - won't use
# --hostname <string> Set a host name for the container - might use?
# --memory <integer> (16 - N) (default = 512), we'll set 2Gb in config
# --mp[n] [volume=]<volume> ,mp=<Path> [,acl=<1|0>] [,backup=<1|0>]
#   [,mountoptions=<opt[;opt...]>] [....] [,size=<DiskSize>]
#   Use volume as container mount point. Use the special syntax
#   STORAGE_ID:SIZE_IN_GiB to allocate a new volume.
# --net[n] name=<string> [,bridge=<bridge>] [,firewall=<1|0>]
#   [,gw=<GatewayIPv4>] [,gw6=<GatewayIPv6>] [,hwaddr=<XX:XX:XX:XX:XX:XX>]
#   [,ip=<(IPv4/CIDR|dhcp|manual)>] [,ip6=<(IPv6/CIDR|auto|dhcp|manual)>]
#   [,link_down=<1|0>] [,mtu=<integer>] [,rate=<mbps>] [,tag=<integer>]
#   [,trunks=<vlanid[;vlanid...]>] [,type=<veth>]
#   Specifies network interfaces for the container. - will set defaults
#   in config file
# --onboot <boolean> (default = 0) will set 1 in config
#   Specifies whether a container will be started during system bootup.
# --ostype <alpine | archlinux | centos | debian | devuan | fedora |
#   gentoo | nixos | opensuse | ubuntu | unmanaged>
#  OS type. This is used to setup configuration inside the container,
#  and corresponds to lxc setup scripts in
#  /usr/share/lxc/config/<ostype>.common.conf. Value unmanaged can be
#  used to skip and OS specific setup. We'll set centos in config
# --rootfs [volume=]<volume> [,acl=<1|0>] [,mountoptions=<opt[;opt...]>]
#   [,quota=<1|0>] [,replicate=<1|0>] [,ro=<1|0>] [,shared=<1|0>]
#   [,size=<DiskSize>]
#   Use volume as container root. - will set 4-8Gb in config file
# --ssh-public-keys <filepath>
#   Setup public SSH keys (one key per line, OpenSSH format).
#   will set defaults in config file
# --storage <storage ID> (default = local)
#   Default Storage. - may we will set in config file
# --swap <integer> (0 - N) (default = 512)
#   Amount of SWAP for the container in MB. - will keep unchanged
#
#
# Parse command-line options
options=$(
getopt -o n:t:P:i:r:a:b:g:m:d:p:f \
  -l help,name:,target:,port:,id:,root:,\
  ip:,bridge:,gw:,ram:,data:,pass:,foo: -- "$@")

if [ $? -ne 0 ]; then
    usage "$(basename "$0")"
    exit 1
fi
eval set -- "$options"

# Process command-line options
while true
do
    case "$1" in
        -h|--help)          usage "$0" && exit 0;;
        -n|--name)          name=$2; shift 2;;
        -t|--target)        target=$2; shift 2;;
        -P|--port)          port=$2; shift 2;;
        -i|--id)            id=$2; shift 2;;
        -r|--root)          rootsize=$2; shift 2;;
        -a|--ip)            ip=$2; shift 2;;
        -b|--bridge)        bridge=$2; shift 2;;
        -g|--gw)       gateway=$2; shift 2;;
        -m|--ram)        memory=$2; shift 2;;
        -p|--pass)          password=$2; shift 2;;
        -d|--data)          storage=$2; shift 2;;
        --)                 shift 2; break ;;
        *)                  break ;;
    esac
done

# Function to collect file system data, excluding unnecessary 
# directories and files
collectFS() {
    tar -cvpf - -C / \
	--exclude="sys" \
	--exclude="dev" \
	--exclude="proc" \
	--exclude="run" \
	--exclude="mnt" \
	--exclude="tmp/*" \
	--exclude="media" \
	--exclude="*.log" \
	--exclude="*.log*" \
	--exclude="*_log-*"
	--exclude="*.gz" \
	--exclude="*.sql" \
	--exclude="swap*" \
	.
}
# Check if remote SQL is running
chk_remote() {
  chk_sql="$(ssh -p "$port" "root@$target" '/bin/ps aux | \
    grep -qi sql> /dev/null 2>&1;echo $?')"
if [[ $chk_sql -eq 0 ]]; then
  echo "Remote SQL is running, please stop it first"
  echo "for DB files consistancy"
  exit 1
fi
}

# SSH into the target machine, execute the file system collection function, and save to a temporary file
mk_template() {
ssh -p "$port" "root@$target" \
  "$(typeset -f collectFS); collectFS" | gzip > "/tmp/$name.tar.gz"
}

# Create a Proxmox container using the collected file system data and provided parameters
pct create "$id" "/tmp/$name.tar.gz" \
  -description LXC \
  -hostname "$name" \
  --features nesting=1 \
  -memory "$memory" -nameserver 8.8.8.8 \
  -net0 name=eth0,ip="$ip"/24,gw="$gateway",bridge="$bridge" \
  --rootfs "$rootsize" -storage "$storage" -password "$password"

# Remove the temporary file
rm -rf "/tmp/$name.tar.gz"
